diff --git a/vendor/riscv/riscv-isa-sim/riscv/Params.cc b/vendor/riscv/riscv-isa-sim/riscv/Params.cc
index f4a88ac02..6e44a063f 100644
--- a/vendor/riscv/riscv-isa-sim/riscv/Params.cc
+++ b/vendor/riscv/riscv-isa-sim/riscv/Params.cc
@@ -40,7 +40,7 @@ void print_center(string &str, const size_t line_length) {
 static size_t name_column = 50;
 static size_t type_column = 30;
 static size_t default_type_column = 40;
-static size_t description_column = 60;
+static size_t description_column = 100;
 static size_t table_size =
     name_column + type_column + default_type_column + description_column;
 
@@ -81,6 +81,7 @@ void Params::print_table(string param_set) {
   std::vector<string> keys;
   for (auto it2 = it->second.begin(); it2 != it->second.end(); ++it2)
     keys.push_back(it2->first);
+
   sort(keys.begin(), keys.end());
 
   // Print each param
diff --git a/vendor/riscv/riscv-isa-sim/riscv/Params.h b/vendor/riscv/riscv-isa-sim/riscv/Params.h
index 42eb8c905..fb500a694 100644
--- a/vendor/riscv/riscv-isa-sim/riscv/Params.h
+++ b/vendor/riscv/riscv-isa-sim/riscv/Params.h
@@ -33,7 +33,7 @@ public:
   //              Base                 Name
   std::unordered_map<string, mapParam> v;
 
-  Param operator[](string str) { return this->get(str); }
+  Param operator[](string str) const { return this->get(str); }
 
 #if 0
   void set(string base, string name, any value, string type = "",
@@ -126,17 +126,38 @@ public:
     }
   }
 
-  Param get(string base, string name) {
+  bool exist(string base, string name) {
+    auto it = v.find(base);
+    if (it != v.end()) {
+      auto it2 = it->second.find(name);
+      if (it2 != it->second.end())
+        return true;
+    }
+    return false;
+  }
+
+  bool exist(string str) {
+    string base, name;
+    std::size_t n_base = str.find_last_of("/");
+    if (n_base != std::string::npos) {
+      base = str.substr(0, n_base + 1);
+      name = str.substr(n_base + 1, str.length());
+      return this->exist(base, name);
+    }
+    return false;
+  }
+
+  Param get(string base, string name) const {
     auto it = v.find(base);
     if (it != this->v.end()) {
       auto it2 = it->second.find(name);
       if (it2 != it->second.end())
-        return v[base][name];
+        return it2->second;
     }
     return Param();
   }
 
-  Param get(string str) {
+  Param get(string str) const {
     string base, name;
     std::size_t n_base = str.find_last_of("/");
     if (n_base != std::string::npos) {
diff --git a/vendor/riscv/riscv-isa-sim/riscv/Proc.cc b/vendor/riscv/riscv-isa-sim/riscv/Proc.cc
index c3d414990..f92345e89 100644
--- a/vendor/riscv/riscv-isa-sim/riscv/Proc.cc
+++ b/vendor/riscv/riscv-isa-sim/riscv/Proc.cc
@@ -1,6 +1,10 @@
 #include "Proc.h"
 #include "disasm.h"
 #include "extension.h"
+#include "arith.h"
+#include "common.h"
+#include "config.h"
+#include "decode_macros.h"
 #include <algorithm>
 #include <assert.h>
 #include <cinttypes>
@@ -13,112 +17,189 @@
 #include <string>
 
 namespace openhw {
-st_rvfi Processor::step(size_t n, st_rvfi reference) {
+st_rvfi Processor::step(size_t n, st_rvfi reference_) {
   st_rvfi rvfi;
+
+  this->reference = & reference_;
+
+  bool unified_traps = (this->params[base + "unified_traps"]).a_bool;
+  bool interrupts_injection = (this->params[base + "interrupts_injection"]).a_bool;
+  bool debug_injection = (this->params[base + "debug_injection"]).a_bool;
+  // Use mstatus as a reference
+  bool inverse_csr_access = (reference->csr_addr[0x300] != 0x300);
+#define INDEX_CSR(INDEX) (inverse_csr_access) ? CSR_MAX_SIZE-1-INDEX : INDEX
+
   memset(&rvfi, 0, sizeof(st_rvfi));
 
-  this->taken_trap = false;
-  this->which_trap = 0;
-
-  rvfi.pc_rdata = this->get_state()->pc;
-  processor_t::step(n);
-
-  rvfi.mode = this->get_state()->last_inst_priv;
-  rvfi.insn =
-      (uint32_t)(this->get_state()->last_inst_fetched.bits() & 0xffffffffULL);
-
-  // TODO FIXME Handle multiple/zero writes in a single insn.
-  auto &reg_commits = this->get_state()->log_reg_write;
-  int xlen = this->get_state()->last_inst_xlen;
-  int flen = this->get_state()->last_inst_flen;
-
-  rvfi.rs1_addr = this->get_state()->last_inst_fetched.rs1();
-  // TODO add rs1_value
-  rvfi.rs2_addr = this->get_state()->last_inst_fetched.rs2();
-  // TODO add rs2_value
-
-  rvfi.trap = this->taken_trap;
-  rvfi.trap |= (this->which_trap << 1);
-
-  bool got_commit = false;
-  for (auto &reg : reg_commits) {
-      if ((reg.first >> 4) > 32) {
-          if ((reg.first >> 4) < 0xFFF) {
-            for (size_t i = 0; i < CSR_SIZE; i++) {
-                if (!rvfi.csr_valid[i]) {
-                    rvfi.csr_valid[i] = 1;
-                    rvfi.csr_addr[i] = reg.first >> 4;
-                    rvfi.csr_wdata[i] = reg.second.v[0];
-                    rvfi.csr_wmask[i] = -1;
-                    break;
+  do {
+    // First intr of the trap handler
+    if (this->taken_trap) {
+        rvfi.intr = 1;
+        if (this->which_trap >> 31) {
+            this->get_state()->mip->backdoor_write(0);
+        }
+    }
+
+    rvfi.pc_rdata = this->get_state()->pc;
+
+    if (this->is_waiting_for_interrupt())
+        this->clear_waiting_for_interrupt();
+
+    if (reference->intr && interrupts_injection && !this->taken_trap) {
+        // We need to ensure this is an interrupt to inject mip
+        if (reference->csr_rdata[INDEX_CSR(CSR_MCAUSE)] >> 31) {
+            uint64_t mip = this->mcause_to_mip(reference->csr_rdata[INDEX_CSR(CSR_MCAUSE)]);
+            this->get_state()->mip->backdoor_write(mip);
+            this->interrupt_injected = true;
+        }
+    }
+
+    if (reference->trap && debug_injection && !this->halted()) {
+        uint64_t cause = reference->csr_rdata[INDEX_CSR(CSR_DCSR)] >> 6;
+        cause = cause & 0b111;
+        switch (cause) {
+            case 0x3:
+                halt_request = HR_REGULAR;
+                break;
+            default:
+                break;
+        }
+    }
+
+    this->taken_trap = false;
+    this->which_trap = 0;
+
+    processor_t::step(n);
+
+    this->interrupt_injected = false;
+
+    if (this->taken_trap) {
+        if (this->which_trap >> 31) {
+            rvfi.intr = this->taken_trap;
+            rvfi.intr |= (this->which_trap << 1);
+        }
+        else {
+            rvfi.trap = this->taken_trap;
+            rvfi.trap |= (this->which_trap << 1);
+        }
+    }
+
+    rvfi.mode = this->get_state()->last_inst_priv;
+    rvfi.insn =
+        (uint32_t)(this->get_state()->last_inst_fetched.bits() & 0xffffffffULL);
+
+    // TODO FIXME Handle multiple/zero writes in a single insn.
+    auto &reg_commits = this->get_state()->log_reg_write;
+    int xlen = this->get_state()->last_inst_xlen;
+    int flen = this->get_state()->last_inst_flen;
+
+    rvfi.rs1_addr = this->get_state()->last_inst_fetched.rs1();
+    // TODO add rs1_value
+    rvfi.rs2_addr = this->get_state()->last_inst_fetched.rs2();
+    // TODO add rs2_value
+
+    bool got_commit = false;
+    for (auto &reg : reg_commits) {
+        if ((reg.first >> 4) > 32) {
+            if ((reg.first >> 4) < 0xFFF) {
+                reg_t addr = reg.first >> 4;
+                rvfi.csr_valid[INDEX_CSR(addr)] = 1;
+                rvfi.csr_addr [INDEX_CSR(addr)] = addr;
+                rvfi.csr_wdata[INDEX_CSR(addr)] = reg.second.v[0];
+                rvfi.csr_wmask[INDEX_CSR(addr)] = -1;
+            }
+        }
+        else {
+            // TODO FIXME Take into account the XLEN/FLEN for int/FP values.
+            rvfi.rd1_addr = reg.first >> 4;
+            rvfi.rd1_wdata = reg.second.v[0];
+            // TODO FIXME Handle multiple register commits per cycle.
+            // TODO FIXME This must be handled on the RVFI side as well.
+        }
+    }
+
+    if (csr_counters_injection) {
+      // Inject values comming from the reference
+      if ((rvfi.insn & MASK_CSRRS) == MATCH_CSRRS ||
+          (rvfi.insn & MASK_CSRRSI) == MATCH_CSRRSI ||
+          (rvfi.insn & MASK_CSRRC) == MATCH_CSRRC ||
+          (rvfi.insn & MASK_CSRRCI) == MATCH_CSRRCI ||
+          (rvfi.insn & MASK_CSRRW) == MATCH_CSRRW ||
+          (rvfi.insn & MASK_CSRRWI) == MATCH_CSRRWI ) {
+
+          reg_t read_csr = this->get_state()->last_inst_fetched.csr();
+          switch (read_csr) {
+          case CSR_MIP: // MIP
+          case 0xC00: // cycle
+          case 0xC80: // cycleh
+          case 0xB00: // mcycle
+          case 0xB80: // mcycleh
+
+            if (reference->rd1_addr) {
+              this->set_XPR(reference->rd1_addr, reference->rd1_wdata);
+              rvfi.rd1_wdata = reference->rd1_wdata;
+            }
+
+            // If it is set or clear we need to inject also the value in the CSR
+            if ((rvfi.insn & MASK_CSRRC) == MATCH_CSRRC ||
+                (rvfi.insn & MASK_CSRRS) == MATCH_CSRRS) {
+                if (reference->csr_valid[read_csr]) {
+                    this->put_csr(read_csr, reference->csr_wdata[read_csr]);
+                    rvfi.csr_wdata[read_csr] = reference->csr_wdata[read_csr];
                 }
             }
+            break;
+          default:
+            break;
           }
       }
-      else {
-        // TODO FIXME Take into account the XLEN/FLEN for int/FP values.
-        rvfi.rd1_addr = reg.first >> 4;
-        rvfi.rd1_wdata = reg.second.v[0];
-        // TODO FIXME Handle multiple register commits per cycle.
-        // TODO FIXME This must be handled on the RVFI side as well.
-      }
-  }
+    }
 
-  if (csr_counters_injection) {
-    // Inject values comming from the reference
-    if ((rvfi.insn & MASK_CSRRS) == MATCH_CSRRS) {
-      if (rvfi.rs1_addr == 0) {
-        reg_t read_csr = this->get_state()->last_inst_fetched.csr();
-        switch (read_csr) {
-        case 0xC00: // cycle
-        case 0xC80: // cycleh
-        case 0xB00: // mcycle
-        case 0xB80: // mcycleh
-          this->set_XPR(reference.rd1_addr, reference.rd1_wdata);
-          rvfi.rd1_wdata = reference.rd1_wdata;
-          break;
-        default:
-          break;
-        }
-      }
+    // Remove sign extension applied by Spike in 32b mode.
+    if (this->get_xlen() == 32) {
+      rvfi.pc_rdata &= 0xffffffffULL;
+      rvfi.rd1_wdata &= 0xffffffffULL;
     }
-  }
 
-  // Remove sign extension applied by Spike in 32b mode.
-  if (this->get_xlen() == 32) {
-    rvfi.pc_rdata &= 0xffffffffULL;
-    rvfi.rd1_wdata &= 0xffffffffULL;
-  }
+  } while (unified_traps && this->taken_trap == true && (this->which_trap >> 31));
+
   return rvfi;
 }
 
 Processor::Processor(
     const isa_parser_t *isa, const cfg_t *cfg, simif_t *sim, uint32_t id,
     bool halt_on_reset, FILE *log_file, std::ostream &sout_,
-    Params &params) // because of command line option --log and -s we need both
+    Params &params_) // because of command line option --log and -s we need both
     : processor_t::processor_t(isa, cfg, sim, id, halt_on_reset, log_file,
                                sout_) {
 
   std::map<string, bool> registered_extensions_v;
   registered_extensions_v["cv32a60x"] = false;
+  registered_extensions_v["cvxif"] = false;
 
-  string base = "/top/core/" + std::to_string(id) + "/";
+  base = "/top/core/" + std::to_string(id) + "/";
   Processor::default_params(base, this->params);
-  Params::parse_params(base, this->params, params);
+  Params::parse_params(base, this->params, params_);
 
   string isa_str = this->params[base + "isa"].a_string;
   string priv_str = this->params[base + "priv"].a_string;
-  std::cout << "[SPIKE] Proc 0 | ISA: " << isa_str << " PRIV: " << priv_str << std::endl;
   this->isa =
       (const isa_parser_t *)new isa_parser_t(isa_str.c_str(), priv_str.c_str());
+  std::cout << "[SPIKE] Proc 0 | ISA: " << isa_str << " PRIV: " << priv_str << std::endl;
+  std::cout << "[SPIKE]     Non standard interrupts " << this->params[base + "non_standard_interrupts"].a_bool << std::endl;
+
+  ((cfg_t *)cfg)->priv = priv_str.c_str();
 
-  disassembler = new disassembler_t(isa);
+  uint64_t trigger_count = this->params[base + "trigger_count"].a_uint64_t;
+  ((cfg_t *)cfg)->trigger_count = trigger_count;
 
-  for (auto e : isa->get_extensions()) {
+  disassembler = new disassembler_t(this->isa);
+
+  for (auto e : this->isa->get_extensions()) {
     register_extension(e.second);
   }
 
-  this->n_pmp = (this->params[base + "pmpregions"]).a_uint64_t;
+  processor_t::set_pmp_num(this->params[base + "pmpregions"].a_uint64_t);
 
   ((cfg_t *)cfg)->misaligned =
       (this->params[base + "misaligned"]).a_bool;
@@ -130,23 +211,24 @@ Processor::Processor(
       (this->params[base + "extensions"]).a_string;
 
   string delimiter = ",";
-  size_t found = extensions_str.rfind(delimiter);
 
-  if (found == string::npos && extensions_str != "") {
-    extensions_str = extensions_str + delimiter;
-  }
+  extensions_str = extensions_str + delimiter;
 
-  while (found != string::npos) {
-    string token = extensions_str.substr(found + delimiter.length(),
-                                         extensions_str.length() - 1);
-    extensions_str = extensions_str.substr(0, found);
-    auto it = registered_extensions_v.find(token);
-    if (it != registered_extensions_v.end())
-      it->second = true;
-    else
-      std::cout << "[SPIKE] Extension \"" << token << "\" can not be registered"
-                << std::endl;
+  size_t found = extensions_str.rfind(delimiter);
 
+  while (found != string::npos) {
+    string token = extensions_str.substr(0, found);
+    extensions_str = extensions_str.substr(found + delimiter.length(), extensions_str.length());
+    if (token != "") {
+      auto it = registered_extensions_v.find(token);
+      if (it != registered_extensions_v.end()) {
+        std::cout << "[SPIKE] Activating extension: " << token << std::endl;
+        it->second = true;
+      }
+      else
+        std::cout << "[SPIKE] Extension \"" << token << "\" can not be registered"
+                  << std::endl;
+    }
     found = extensions_str.rfind(delimiter);
   }
 
@@ -159,39 +241,6 @@ Processor::Processor(
   }
 
   this->reset();
-
-  uint64_t new_pc = (this->params[base + "boot_addr"]).a_uint64_t;
-  this->state.pc = new_pc;
-
-  this->put_csr(CSR_PMPADDR0, (this->params[base + "pmpaddr0"]).a_uint64_t);
-  this->put_csr(CSR_PMPCFG0, (this->params[base + "pmpcfg0"]).a_uint64_t);
-
-  this->state.csrmap[CSR_MVENDORID] =
-      std::make_shared<const_csr_t>(this, CSR_MVENDORID, (this->params[base + "mvendorid"]).a_uint64_t);
-  this->state.csrmap[CSR_MHARTID] =
-      std::make_shared<const_csr_t>(this, CSR_MHARTID, (this->params[base + "mhartid"]).a_uint64_t);
-  this->state.csrmap[CSR_MARCHID] =
-      std::make_shared<const_csr_t>(this, CSR_MHARTID, (this->params[base + "marchid"]).a_uint64_t);
-
-  bool fs_field_we_enable = (this->params[base + "status_fs_field_we_enable"]).a_bool;
-  bool fs_field_we = (this->params[base + "status_fs_field_we"]).a_bool;
-  bool vs_field_we_enable = (this->params[base + "status_vs_field_we_enable"]).a_bool;
-  bool vs_field_we = (this->params[base + "status_vs_field_we"]).a_bool;
-
-  reg_t sstatus_mask = this->state.mstatus->get_param_write_mask();
-  if (fs_field_we_enable)
-    sstatus_mask = (fs_field_we ? (sstatus_mask | MSTATUS_FS)
-                                : (sstatus_mask & ~MSTATUS_FS));
-  if (vs_field_we_enable)
-    sstatus_mask = (vs_field_we ? (sstatus_mask | MSTATUS_VS)
-                                : (sstatus_mask & ~MSTATUS_VS));
-  this->state.mstatus->set_param_write_mask(sstatus_mask);
-
-  bool misa_we_enable =
-      (this->params[base + "misa_we_enable"]).a_bool;
-  bool misa_we = (this->params[base + "misa_we"]).a_bool;
-  if (misa_we_enable)
-    this->state.misa->set_we(misa_we);
 }
 
 void Processor::take_trap(trap_t &t, reg_t epc) {
@@ -200,13 +249,16 @@ void Processor::take_trap(trap_t &t, reg_t epc) {
   processor_t::take_trap(t, epc);
 }
 
-Processor::~Processor() { delete this->isa; }
+Processor::~Processor() {
+    delete this->isa;
+    for (auto e : this->custom_extensions)
+        delete e.second;
+}
 
 void Processor::default_params(string base, openhw::Params &params) {
   params.set_string(base, "isa", "RV32GC", "RV32GC",
              "ISA");
-  params.set_string(base, "priv", DEFAULT_PRIV,
-             DEFAULT_PRIV, "Privilege Level");
+  params.set_string(base, "priv", DEFAULT_PRIV, DEFAULT_PRIV, "Privilege Level");
   params.set_uint64_t(base, "boot_addr", 0x80000000UL, "0x80000000UL",
              "First PC of the core");
   params.set_string(base, "mmu_mode", "sv39", "sv39",
@@ -232,16 +284,67 @@ void Processor::default_params(string base, openhw::Params &params) {
              "XSTATUS CSR VS Write Enable param enable");
   params.set_bool(base, "status_vs_field_we", false, "false",
              "XSTATUS CSR VS Write Enable");
-  params.set_bool(base, "misa_we_enable", true, "true",
-             "MISA CSR Write Enable param enable");
-  params.set_bool(base, "misa_we", false, "false",
-             "MISA CSR Write Enable value");
+  params.set_bool(base, "status_xs_field_we_enable", (false), "false",
+             "XSTATUS CSR XS Write Enable param enable");
+  params.set_bool(base, "status_xs_field_we", (false), "false",
+             "XSTATUS CSR XS Write Enable");
 
   params.set_bool(base, "misaligned", false, "false",
              "Support for misaligned memory operations");
 
   params.set_bool(base, "csr_counters_injection", false, "false",
-             "Allow to set CSRs getting values from a DPI");
+             "Allow to set CSRs getting values from DPI");
+
+  params.set_bool(base, "interrupts_injection", true, "true",
+             "Allow to set MIP csr with values from DPI");
+
+  params.set_bool(base, "debug_injection", true, "true",
+             "Allow to enter in debug mode with values from DPI");
+
+  params.set_bool(base, "hide_csrs_based_on_priv", false, "false",
+             "Allow to hide CSRs based on priv modes available.");
+
+  params.set_uint64_t(base, "mtvec_vectored_alignment", 0x4UL, "0x4",
+             "Default alignment for mtvec when vector mode active");
+
+  params.set_bool(base, "override_custom_extensions", true, "false",
+             "Allow to override custom extensions value.");
+
+  params.set_bool(base, "override_custom_extensions_value", false, "false",
+             "Value for the custom extensions override.");
+
+  params.set_bool(base, "non_standard_interrupts", false, "false",
+             "Value for the custom extensions override.");
+
+  params.set_bool(base, "unified_traps", false, "false",
+             "Unify all kind of traps with the exceptions.");
+
+  params.set_uint64_t(base, "nmi_mcause", 0x00000020, "0x00000020",
+             "Value of MCAUSE in case of NMI. It does not include the interrupt bit.");
+
+  for (auto it = Processor::csr_params.begin(); it != Processor::csr_params.end(); it++) {
+      string csr_name = it->second.name;
+      if (it->second.override_mask_param) {
+        params.set_uint64_t(base, csr_name + "_override_value", (0x0UL), "0x0",
+                    csr_name + " CSR override value");
+        params.set_uint64_t(base, csr_name + "_override_mask", (0x0UL), "0x0",
+                    csr_name + " CSR override mask");
+      }
+      if (it->second.presence_param) {
+        params.set_bool(base, csr_name + "_presence", true, "true",
+                    csr_name + " CSR presence");
+      }
+      if (it->second.write_enable_param) {
+        params.set_bool(base, csr_name + "_we_enable", false, "false",
+                    csr_name +" CSR Write Enable param enable");
+        params.set_bool(base, csr_name + "_we", false, "false",
+                    csr_name + " CSR Write Enable value");
+      }
+  }
+
+  params.set_uint64_t(base, "trigger_count", 0x0000004, "0x00000004",
+             "Number of enabled triggers");
+
 }
 
 inline void Processor::set_XPR(reg_t num, reg_t value) {
@@ -252,4 +355,178 @@ inline void Processor::set_FPR(reg_t num, float128_t value) {
   this->state.FPR.write(num, value);
 }
 
+void Processor::put_csr(int which, reg_t val)
+{
+  val = zext_xlen(val);
+  auto search = state.csrmap.find(which);
+  if (search != state.csrmap.end()) {
+    search->second->write(val);
+    return;
+  }
+}
+
+reg_t Processor::get_csr(int which, insn_t insn, bool write, bool peek)
+{
+  auto search = get_state()->csrmap.find(which);
+  if (search != state.csrmap.end()) {
+    search->second->custom_checks(insn, write);
+    if (!peek) {
+      search->second->verify_permissions(insn, write);
+    }
+    return search->second->read();
+  }
+  // If we get here, the CSR doesn't exist.  Unimplemented CSRs always throw
+  // illegal-instruction exceptions, not virtual-instruction exceptions.
+  throw trap_illegal_instruction(insn.bits());
+}
+
+void Processor::reset()
+{
+    processor_t::reset();
+
+    uint64_t new_pc = (this->params[base + "boot_addr"]).a_uint64_t;
+    this->state.pc = new_pc;
+
+    this->put_csr(CSR_PMPADDR0, (this->params[base + "pmpaddr0"]).a_uint64_t);
+    this->put_csr(CSR_PMPCFG0, (this->params[base + "pmpcfg0"]).a_uint64_t);
+
+    uint64_t max_misa = this->isa->get_max_isa();
+    this->state.csrmap[CSR_MISA] = this->state.misa =
+        std::make_shared<misa_csr_t>(this, CSR_MISA, max_misa);
+
+    this->get_state()->csrmap[CSR_MSCONTEXT] = std::make_shared<proxy_csr_t>(this, CSR_MSCONTEXT, this->get_state()->csrmap[CSR_MCONTEXT]);
+
+    this->get_state()->debug_mode = 1;
+
+    for (auto it = Processor::csr_params.begin(); it != Processor::csr_params.end(); it++) {
+        string csr_name = it->second.name;
+
+        openhw::reg* p_csr = (openhw::reg*) this->state.csrmap[it->first].get();
+
+
+        if (it->second.override_mask_param) {
+            uint64_t override_mask = (this->params[base + csr_name + "_override_mask"]).a_uint64_t;
+            uint64_t override_value = (this->params[base + csr_name + "_override_value"]).a_uint64_t;
+
+            uint64_t val = p_csr->unlogged_read();
+            val = (~override_mask & val) | (override_mask & override_value);
+            // Write the value to the CSR
+            p_csr->backdoor_write(val);
+            // Affect possible dependencies
+            p_csr->write(val);
+        }
+
+        if (it->second.presence_param) {
+            bool presence = (this->params[base + csr_name + "_presence"]).a_bool;
+            auto csr_it = state.csrmap.find(it->first);
+            if (csr_it != state.csrmap.end() and !presence)
+                state.csrmap.erase(csr_it);
+        }
+
+        if (it->second.write_enable_param) {
+            bool we_enable = (this->params[base + csr_name + "_we_enable"]).a_bool;
+            bool we = (this->params[base + csr_name + "_we"]).a_bool;
+            if (we_enable)
+                p_csr->set_we(we);
+        }
+
+
+    }
+
+    this->get_state()->debug_mode = 0;
+
+    bool fs_field_we_enable = (this->params[base + "status_fs_field_we_enable"]).a_bool;
+    bool fs_field_we = (this->params[base + "status_fs_field_we"]).a_bool;
+    bool vs_field_we_enable = (this->params[base + "status_vs_field_we_enable"]).a_bool;
+    bool vs_field_we = (this->params[base + "status_vs_field_we"]).a_bool;
+    bool xs_field_we_enable = (this->params[base + "status_xs_field_we_enable"]).a_bool;
+    bool xs_field_we = (this->params[base + "status_xs_field_we"]).a_bool;
+
+    reg_t sstatus_mask = this->state.csrmap[CSR_MSTATUS]->get_param_write_mask();
+    if (fs_field_we_enable)
+        sstatus_mask = (fs_field_we ? (sstatus_mask |  MSTATUS_FS)
+                                    : (sstatus_mask & ~MSTATUS_FS));
+    if (vs_field_we_enable)
+        sstatus_mask = (vs_field_we ? (sstatus_mask |  MSTATUS_VS)
+                                    : (sstatus_mask & ~MSTATUS_VS));
+
+    if (xs_field_we_enable)
+        sstatus_mask = (xs_field_we ? (sstatus_mask |  MSTATUS_XS)
+                                    : (sstatus_mask & ~MSTATUS_XS));
+
+    this->state.csrmap[CSR_MSTATUS]->set_param_write_mask(sstatus_mask);
+
+    // Hide CSR Priv param implementation
+    bool hide_csr_priv = (this->params[base + "hide_csr_priv"]).a_bool;
+    std::string s = this->get_cfg().priv();
+    if (hide_csr_priv) {
+        for (auto it = this->get_state()->csrmap.begin(); it != this->get_state()->csrmap.end() ; it++) {
+            bool legal = false;
+            for (size_t i = 0 ; i < s.length() && !legal; i++) {
+                std::tuple <uint64_t, uint64_t> range = Processor::priv_ranges[s[i]];
+                if (std::get<0>(range) <= it->first && it->first < get<1>(range)) {
+                    legal = true;
+                }
+            }
+            if (!legal) {
+                this->get_state()->csrmap.erase(it);
+            }
+        }
+    }
+
+}
+
+void Processor::take_pending_interrupt() {
+    uint64_t mie = (state.mie->read());
+    uint64_t mip = (state.mip->read());
+    take_interrupt(mip & mie);
+}
+
+void Processor::take_interrupt(reg_t pending_interrupts) {
+
+  processor_t::take_interrupt(pending_interrupts);
+
+  if (this->interrupt_injected && !this->taken_trap && pending_interrupts == 0) {
+    uint64_t nmi_mcause = (this->params[base + "nmi_mcause"]).a_uint64_t;
+    throw trap_t(((reg_t)1 << (isa->get_max_xlen() - 1)) | nmi_mcause);
+  }
+  return;
+}
+
+uint32_t Processor::mcause_to_mip(uint32_t mcause) {
+    // Check if the cause is an interrupt (MSB = 1)
+    if (mcause >> 31) {
+        uint32_t interrupt_id = mcause & 0x7FFFFFFF; // Mask out the interrupt bit to get the ID
+        switch (interrupt_id) {
+            case 3: return MIP_MSIP;   // Software interrupt
+            case 7: return MIP_MTIP;   // Timer interrupt
+            case 11: return MIP_MEIP;  // External interrupt
+            default:
+                if (32 > interrupt_id && interrupt_id > 15) {
+                    return 1 << (interrupt_id);
+                }
+                return 0;         // Unknown or unhandled interrupt
+        }
+    }
+    return 0; // Not an interrupt
+}
+
+std::unordered_map<uint64_t, openhw::csr_param_t> Processor::csr_params = {
+    // ADDRESS          NAME      OVERRIDE_MASKS_PARAM   PRESENCE_PARAM  WRITE_ENABLE_PARAM
+    { CSR_MSTATUS   , {"mstatus"    ,  true    ,           false       ,      true} },
+    { CSR_MISA      , {"misa"       ,  true    ,           false       ,      true} },
+    { CSR_MHARTID   , {"mhartid"    ,  true    ,           false       ,      true} },
+    { CSR_MARCHID   , {"marchid"    ,  true    ,           false       ,      true} },
+    { CSR_MVENDORID , {"mvendorid"  ,  true    ,           false       ,      true} },
+    { CSR_TDATA1    , {"tdata1"     ,  true    ,           false       ,      true} },
+    { CSR_TINFO     , {"tinfo"      ,  true    ,           true        ,      true} },
+    { CSR_MSCONTEXT , {"mscontext"  ,  true    ,           true        ,      true} },
+  };
+
+std::unordered_map<char, std::tuple<uint64_t,uint64_t>> Processor::priv_ranges = {
+    { 'M',  {0x300, 0xFFF} },
+    { 'S',  {0x100, 0x200} },
+    { 'U',  {0x0  , 0x100} },
+};
+
 } // namespace openhw
diff --git a/vendor/riscv/riscv-isa-sim/riscv/Proc.h b/vendor/riscv/riscv-isa-sim/riscv/Proc.h
index 5387ce190..771bb2f75 100644
--- a/vendor/riscv/riscv-isa-sim/riscv/Proc.h
+++ b/vendor/riscv/riscv-isa-sim/riscv/Proc.h
@@ -3,12 +3,21 @@
 #include "processor.h"
 
 namespace openhw {
+
+  typedef struct {
+      string name;
+      bool override_mask_param;
+      bool presence_param;
+      bool write_enable_param;
+  } csr_param_t;
+
+
 class Processor : public processor_t {
 public:
   Processor(const isa_parser_t *isa, const cfg_t *cfg, simif_t *sim,
             uint32_t id, bool halt_on_reset, FILE *log_file,
             std::ostream &sout_,
-            Params &params); // because of command line option --log and -s we
+            Params &params_); // because of command line option --log and -s we
                              // need both
   ~Processor();
   st_rvfi step(size_t n, st_rvfi reference);
@@ -17,12 +26,41 @@ public:
 
   inline void set_XPR(reg_t num, reg_t value);
   inline void set_FPR(reg_t num, float128_t value);
+  inline const Params& get_params() const { return params; }
+
+  inline const string get_base() { return base; }
+
+  void take_pending_interrupt();
+  void take_interrupt(reg_t pending_interrupts);
+
+  void reset();
+
+  bool any_custom_extensions() const override {
+    if ((this->get_params()[base + "override_custom_extensions"]).a_bool)
+        return (this->get_params()[base + "override_custom_extensions_value"]).a_bool;
+
+    return !custom_extensions.empty();
+  }
+
+  virtual void put_csr(int which, reg_t val);
+
+  virtual reg_t get_csr(int which, insn_t insn, bool write, bool peek = 0);
+
+  inline uint32_t mcause_to_mip(uint32_t mcause);
 
 protected:
   bool csr_counters_injection;
+  bool interrupt_injected;
   bool taken_trap;
-  uint8_t which_trap;
+  uint64_t which_trap;
+  string base;
   virtual void take_trap(trap_t &t, reg_t epc); // take an exception
+  st_rvfi *reference;
+
+  static std::unordered_map<uint64_t, csr_param_t> csr_params;
+
+  static std::unordered_map<char, std::tuple<uint64_t, uint64_t>> priv_ranges;
+
 };
 
 } // namespace openhw
diff --git a/vendor/riscv/riscv-isa-sim/riscv/Simulation.cc b/vendor/riscv/riscv-isa-sim/riscv/Simulation.cc
index 551ce790e..e52668af2 100644
--- a/vendor/riscv/riscv-isa-sim/riscv/Simulation.cc
+++ b/vendor/riscv/riscv-isa-sim/riscv/Simulation.cc
@@ -46,7 +46,7 @@ void Simulation::default_params(openhw::Params &params) {
   params.set_uint64_t("/top/", "bootrom_size", 0x1000UL, "0x1000",
              "bootrom size");
 
-  params.set_bool("/top/", "dram", true, "true", "DRAM enable");
+  params.set_bool("/top/", "dram_enable", true, "true", "DRAM enable");
   params.set_uint64_t("/top/", "dram_base", 0x80000000UL,
              "0x80000000", "DRAM base address");
   params.set_uint64_t("/top/", "dram_size", 0x400UL * 1024 * 1024,
@@ -115,7 +115,7 @@ Simulation::Simulation(const cfg_t *cfg, string elf_path,
                  plugin_devs, std::vector<std::string>() = {elf_path},
                  dm_config,
                  "tandem.log", // log_path
-                 true,         // dtb_enabled
+                 false,         // dtb_enabled
                  nullptr,      // dtb_file
                  false,        // socket_enabled
                  NULL,         // cmd_file
@@ -169,7 +169,7 @@ void Simulation::make_mems(const std::vector<mem_cfg_t> &layout) {
     this->mems.push_back(bootrom_device);
   }
 
-  bool dram = (this->params["/top/dram"]).a_bool;
+  bool dram = (this->params["/top/dram_enable"]).a_bool;
   uint64_t dram_base = (this->params["/top/dram_base"]).a_uint64_t;
   uint64_t dram_size = (this->params["/top/dram_size"]).a_uint64_t;
   if (dram) {
@@ -188,6 +188,7 @@ std::vector<st_rvfi> Simulation::step(size_t n,
       continue;
 
     vspike[i] = ((Processor *)procs[i])->step(1, vreference[i]);
+    vspike[i].halt = (sim_t::done() ? ((sim_t::exit_code() << 1) | 1) : 0);
 
     host = context_t::current();
     if (!sim_t::done()) {
diff --git a/vendor/riscv/riscv-isa-sim/riscv/Types.h b/vendor/riscv/riscv-isa-sim/riscv/Types.h
index d0b953fdf..2a8c505d6 100644
--- a/vendor/riscv/riscv-isa-sim/riscv/Types.h
+++ b/vendor/riscv/riscv-isa-sim/riscv/Types.h
@@ -9,7 +9,7 @@
 #include <sys/types.h>
 #include "Params.h"
 
-#define CSR_SIZE 250
+#define CSR_MAX_SIZE 4096
 
 typedef struct {
    uint64_t                 nret_id;
@@ -55,12 +55,13 @@ typedef struct {
    uint64_t                 mem_wdata;
    uint64_t                 mem_wmask;
 
-   uint64_t                 csr_valid   [CSR_SIZE];
-   uint64_t                 csr_addr    [CSR_SIZE];
-   uint64_t                 csr_rdata   [CSR_SIZE];
-   uint64_t                 csr_rmask   [CSR_SIZE];
-   uint64_t                 csr_wdata   [CSR_SIZE];
-   uint64_t                 csr_wmask   [CSR_SIZE];
+   uint64_t                 csr_valid   [CSR_MAX_SIZE];
+   uint64_t                 csr_addr    [CSR_MAX_SIZE];
+   uint64_t                 csr_rdata   [CSR_MAX_SIZE];
+   uint64_t                 csr_rmask   [CSR_MAX_SIZE];
+   uint64_t                 csr_wdata   [CSR_MAX_SIZE];
+   uint64_t                 csr_wmask   [CSR_MAX_SIZE];
 
 } st_rvfi;
 
+
diff --git a/vendor/riscv/riscv-isa-sim/riscv/csrs.cc b/vendor/riscv/riscv-isa-sim/riscv/csrs.cc
index f71e61fa6..626abccf2 100644
--- a/vendor/riscv/riscv-isa-sim/riscv/csrs.cc
+++ b/vendor/riscv/riscv-isa-sim/riscv/csrs.cc
@@ -45,7 +45,6 @@ void csr_t::verify_permissions(insn_t insn, bool write) const {
       throw trap_virtual_instruction(insn.bits());
     throw trap_illegal_instruction(insn.bits());
   }
-  this->custom_verify_permissions(insn, write);
 }
 
 csr_t::~csr_t() {
diff --git a/vendor/riscv/riscv-isa-sim/riscv/csrs.h b/vendor/riscv/riscv-isa-sim/riscv/csrs.h
index d8ceafcdf..fde4d0be5 100644
--- a/vendor/riscv/riscv-isa-sim/riscv/csrs.h
+++ b/vendor/riscv/riscv-isa-sim/riscv/csrs.h
@@ -215,7 +215,7 @@ class vsstatus_csr_t final: public base_status_csr_t {
   vsstatus_csr_t(processor_t* const proc, const reg_t addr);
 
   reg_t read() const noexcept override {
-    return openhw::reg::unlogged_read();
+    return openhw::reg::read();
   }
 
  protected:
@@ -230,7 +230,7 @@ class mstatus_csr_t final: public base_status_csr_t {
   mstatus_csr_t(processor_t* const proc, const reg_t addr);
 
   reg_t read() const noexcept override {
-    return openhw::reg::unlogged_read();
+    return openhw::reg::read();
   }
 
  protected:
diff --git a/vendor/riscv/riscv-isa-sim/riscv/csrs_ext.cc b/vendor/riscv/riscv-isa-sim/riscv/csrs_ext.cc
index f64dbfa30..72fbc3dbb 100644
--- a/vendor/riscv/riscv-isa-sim/riscv/csrs_ext.cc
+++ b/vendor/riscv/riscv-isa-sim/riscv/csrs_ext.cc
@@ -3,10 +3,10 @@
 // For std::any_of
 #include <algorithm>
 
-#include "csrs.h"
 // For processor_t:
 #include "mmu.h"
 #include "processor.h"
+#include "Proc.h"
 // For get_field():
 #include "decode_macros.h"
 // For trap_virtual_instruction and trap_illegal_instruction:
@@ -22,7 +22,8 @@ namespace openhw {
 // implement a middle csr class
 reg::reg(processor_t *const proc, const reg_t addr, const reg_t init)
     : address(addr), value(init), param_write_mask(-1), param_we(true),
-      proc(proc), state(proc->get_state()) {}
+      proc(proc), state(proc->get_state()) {
+      }
 
 void reg::set_we(bool we) noexcept { this->param_we = we; }
 
@@ -36,7 +37,7 @@ reg_t reg::get_param_write_mask() noexcept { return this->param_write_mask; }
 
 bool reg::post_read(const reg_t &val) const noexcept { return true; }
 
-bool reg::pre_write(const reg_t &val) const noexcept {
+bool reg::pre_write(const reg_t &val) noexcept {
   const reg_t curr = this->unlogged_read();
   const reg_t new_val =
       (val & this->param_write_mask) | (curr & ~this->param_write_mask);
@@ -44,16 +45,43 @@ bool reg::pre_write(const reg_t &val) const noexcept {
 
   return true;
 }
-bool reg::post_write(const reg_t &val) const noexcept { return true; }
 
-bool reg::custom_verify_permissions(insn_t insn, bool write) const {
+bool reg::post_write(const reg_t &val) noexcept {
+    // Implement MTVEC alignment parameter
+    if (address == CSR_MTVEC) {
+        reg_t value = this->unlogged_read();
+        if (value & 1) {
+            string param_str = ((Processor*)this->proc)->get_base() + "mtvec_vectored_alignment";
+            reg_t align = ((Processor*)this->proc)->get_params()[param_str].a_uint64_t;
+            reg_t mask = ~(align - 1);
+            reg_t new_val = (value & mask) | 1;
+            this->unlogged_write(new_val);
+        }
+    }
+    else if (address == CSR_MIE || address == CSR_MIP) {
+        reg_t value = this->unlogged_read();
+        string param_str = ((Processor*)this->proc)->get_base() + "non_standard_interrupts";
+        bool clic_mode = ((Processor*)this->proc)->get_params()[param_str].a_bool;
+        if (clic_mode) {
+            reg_t mask = (0x10000 - 0x1);
+            reg_t new_val = (value & mask) | (val & ~mask);
+            this->backdoor_write(new_val);
+            log_write();
+        }
+
+    }
+
+    return true;
+}
+
+
+bool reg::custom_checks(insn_t insn, bool write) const {
   return true;
 }
 
 inline reg_t reg::unlogged_read() const noexcept {
-  auto val = this->value;
-  this->post_read(val);
-  return val;
+  auto ret_val = this->value;
+  return ret_val;
 }
 
 inline bool reg::unlogged_write(reg_t val) noexcept {
@@ -61,7 +89,12 @@ inline bool reg::unlogged_write(reg_t val) noexcept {
   return true;
 }
 
-void reg::write(const reg_t val) noexcept {
+inline bool reg::backdoor_write(reg_t val) noexcept {
+  this->value = val;
+  return true;
+}
+
+void reg::write(const reg_t val, const bool log) noexcept {
   if (!this->param_we)
     return;
 
@@ -69,16 +102,16 @@ void reg::write(const reg_t val) noexcept {
   const bool success = unlogged_write(val);
   this->post_write(val);
 
-  if (success) {
+  if (success && log) {
     log_write();
   }
 }
 void reg::log_write() const noexcept {}
 
 reg_t reg::read() const noexcept {
-  auto val = this->unlogged_read();
-  this->post_read(val);
-  return val;
+  auto ret_val = this->unlogged_read();
+  this->post_read(ret_val);
+  return ret_val;
 }
 
 } // namespace openhw
diff --git a/vendor/riscv/riscv-isa-sim/riscv/csrs_ext.h b/vendor/riscv/riscv-isa-sim/riscv/csrs_ext.h
index 8bcbcb2c3..eaaed34d5 100644
--- a/vendor/riscv/riscv-isa-sim/riscv/csrs_ext.h
+++ b/vendor/riscv/riscv-isa-sim/riscv/csrs_ext.h
@@ -10,6 +10,8 @@
 #include <memory>
 // For access_type:
 #include "memtracer.h"
+#include "csrs.h"
+#include <unordered_map>
 #include <cassert>
 
 class processor_t;
@@ -25,11 +27,13 @@ public:
 
   virtual bool post_read(const reg_t &val) const noexcept;
 
-  virtual bool pre_write(const reg_t &val) const noexcept;
+  virtual bool pre_write(const reg_t &val) noexcept;
 
-  virtual bool post_write(const reg_t &val) const noexcept;
+  virtual bool post_write(const reg_t &val) noexcept;
 
-  bool custom_verify_permissions(insn_t insn, bool write) const;
+  bool custom_checks(insn_t insn, bool write) const;
+
+  bool access_on_priv() const noexcept;
 
   void set_we(bool we) noexcept;
 
@@ -43,7 +47,7 @@ public:
 
   virtual reg_t unlogged_read() const noexcept;
 
-  virtual void write(const reg_t val) noexcept;
+  virtual void write(const reg_t val, const bool log = true) noexcept;
 
   virtual reg_t read() const noexcept;
 
@@ -51,6 +55,8 @@ public:
 
   const reg_t address;
 
+  virtual bool backdoor_write(const reg_t val) noexcept;
+
 private:
   reg_t value;
 
@@ -60,7 +66,6 @@ protected:
 
   processor_t *const proc;
   state_t *const state;
-
   friend class Processor;
 };
 
diff --git a/vendor/riscv/riscv-isa-sim/riscv/processor.h b/vendor/riscv/riscv-isa-sim/riscv/processor.h
index 618c4d56c..13fccd4d7 100644
--- a/vendor/riscv/riscv-isa-sim/riscv/processor.h
+++ b/vendor/riscv/riscv-isa-sim/riscv/processor.h
@@ -197,9 +197,9 @@ public:
   bool get_log_commits_enabled() const { return log_commits_enabled; }
   void reset();
   void step(size_t n); // run for n cycles
-  void put_csr(int which, reg_t val);
+  virtual void put_csr(int which, reg_t val);
   uint32_t get_id() const { return id; }
-  reg_t get_csr(int which, insn_t insn, bool write, bool peek = 0);
+  virtual reg_t get_csr(int which, insn_t insn, bool write, bool peek = 0);
   reg_t get_csr(int which) { return get_csr(which, insn_t(0), false, true); }
   mmu_t* get_mmu() { return mmu; }
   state_t* get_state() { return &state; }
@@ -217,7 +217,7 @@ public:
   }
   extension_t* get_extension();
   extension_t* get_extension(const char* name);
-  bool any_custom_extensions() const {
+  virtual bool any_custom_extensions() const {
     return !custom_extensions.empty();
   }
   bool extension_enabled(unsigned char ext) const {
@@ -334,7 +334,7 @@ protected:
   static const size_t OPCODE_CACHE_SIZE = 8191;
   insn_desc_t opcode_cache[OPCODE_CACHE_SIZE];
 
-  void take_pending_interrupt() { take_interrupt(state.mip->read() & state.mie->read()); }
+  virtual void take_pending_interrupt() { take_interrupt(state.mip->read() & state.mie->read()); }
   void take_interrupt(reg_t mask); // take first enabled interrupt in mask
   virtual void take_trap(trap_t& t, reg_t epc); // take an exception
   void take_trigger_action(triggers::action_t action, reg_t breakpoint_tval, reg_t epc);
diff --git a/vendor/riscv/riscv-isa-sim/spike_main/spike-dpi.cc b/vendor/riscv/riscv-isa-sim/spike_main/spike-dpi.cc
new file mode 100644
index 000000000..e98dac1f7
--- /dev/null
+++ b/vendor/riscv/riscv-isa-sim/spike_main/spike-dpi.cc
@@ -0,0 +1,43 @@
+// See LICENSE for license details.
+
+// xspike forks an xterm for spike's target machine console,
+// preserving the current terminal for debugging.
+
+#include "common.h"
+#include <unistd.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <sys/wait.h>
+#include <string.h>
+#include <cstdio>
+#include <climits>
+#include <cstring>
+#include <stdexcept>
+#include <iostream>
+#include "riscv_dpi.cc"
+
+int main(int UNUSED argc, char** argv)
+{
+
+    for (int i = 0; i < argc; ++i) {
+        std::cout << argv[i] << "\n";
+    }
+    std::string binary;
+    if (argc > 1) {
+      binary = argv[1];
+      spike_set_param_bool("/top/core/0/", "csr_counters_injection", true);
+      spike_set_param_str("/top/", "isa", "rv32imc");
+      spike_set_param_str("/top/", "priv", "MSU");
+      spike_set_param_str("/top/core/0/", "isa", "rv32imc");
+      spike_set_param_str("/top/core/0/", "priv", "MSU");
+
+      spike_create(binary.c_str());
+      st_rvfi spike, reference;
+      uint64_t max_steps = 1000;
+      for(uint64_t i = 0; i < max_steps && ((spike.halt & 1) == 0); i++ ) {
+        spike_step_struct(reference, spike);
+        std::cout << "[TANDEM][PC: " << std::hex << spike.pc_rdata << "][INSN:" << spike.insn << "]" << std::endl;
+        i++;
+      }
+    }
+}
